<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sigil Tracer</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #e7e4dc;
      font-family: Arial, sans-serif;
    }
    
    #app {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    #sigilContainer {
      position: relative;
      width: 80vmin;
      height: 80vmin;
      background-color: #f5f2ea;
      border-radius: 4px;
    }
    
    #sigilSVG {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    #drawCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 3;
      cursor: crosshair;
      border-radius: 4px;
    }
    
    #infoPanel {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 8px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="sigilContainer">
      <div id="sigilSVG"></div>
      <canvas id="drawCanvas"></canvas>
    </div>
    <div id="infoPanel">Initializing sigil tracer...</div>
  </div>

  <script>
    // Get references to DOM elements
    const drawCanvas = document.getElementById('drawCanvas');
    const sigilContainer = document.getElementById('sigilContainer');
    const sigilSVG = document.getElementById('sigilSVG');
    const infoPanel = document.getElementById('infoPanel');
    
    // Get canvas context
    const ctx = drawCanvas.getContext('2d');
    
    // Create a hidden canvas for pixel testing
    const hiddenCanvas = document.createElement('canvas');
    const hiddenCtx = hiddenCanvas.getContext('2d', { willReadFrequently: true });
    
    // Track state
    let isDrawing = false;
    let lastPoint = null;
    let hue = 0;
    let pixelData = null;
    
    // Define sigil data
    const sigilSVGContent = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 300" width="100%" height="100%">
        <!-- Top bar -->
        <rect x="70" y="20" width="60" height="10" fill="black" />
        <!-- Vertical line from top -->
        <rect x="95" y="30" width="10" height="60" fill="black" />
        <!-- Outer circle -->
        <circle cx="100" cy="130" r="40" stroke="black" stroke-width="10" fill="none" />
        <!-- Inner circle -->
        <circle cx="100" cy="130" r="20" stroke="black" stroke-width="10" fill="none" />
        <!-- Bottom vertical line -->
        <rect x="95" y="170" width="10" height="110" fill="black" />
      </svg>
    `;
    
    // Set up event listeners
    function init() {
      // Insert SVG
      sigilSVG.innerHTML = sigilSVGContent;
      
      // Set canvas size
      resizeCanvas();
      
      // Setup event listeners
      window.addEventListener('resize', resizeCanvas);
      
      // Mouse events
      drawCanvas.addEventListener('mousedown', startDrawing);
      drawCanvas.addEventListener('mousemove', draw);
      window.addEventListener('mouseup', stopDrawing);
      
      // Touch events
      drawCanvas.addEventListener('touchstart', handleTouch(startDrawing), { passive: false });
      drawCanvas.addEventListener('touchmove', handleTouch(draw), { passive: false });
      drawCanvas.addEventListener('touchend', stopDrawing);
      drawCanvas.addEventListener('touchcancel', stopDrawing);
      
      // Start animation loop
      requestAnimationFrame(fadeTrail);
      
      // Update info
      infoPanel.textContent = "Ready - trace over the black lines";
      
      // Prepare hidden canvas
      setTimeout(prepareSVGCanvas, 200);
    }
    
    // Set up canvas size
    function resizeCanvas() {
      const containerWidth = sigilContainer.clientWidth;
      const containerHeight = sigilContainer.clientHeight;
      
      // Set canvas dimensions
      drawCanvas.width = containerWidth;
      drawCanvas.height = containerHeight;
      
      // Set hidden canvas dimensions
      hiddenCanvas.width = containerWidth;
      hiddenCanvas.height = containerHeight;
      
      // Clear and prepare
      ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      
      // Redraw hidden canvas
      setTimeout(prepareSVGCanvas, 200);
    }
    
    // Prepare the hidden canvas with SVG data
    function prepareSVGCanvas() {
      // Get the rendered SVG
      const svgElement = sigilSVG.querySelector('svg');
      
      if (!svgElement) {
        infoPanel.textContent = "Error: SVG not found. Try refreshing.";
        return;
      }
      
      // Create a data URL from the SVG
      const svgData = new XMLSerializer().serializeToString(svgElement);
      const svgBlob = new Blob([svgData], { type: 'image/svg+xml' });
      const svgUrl = URL.createObjectURL(svgBlob);
      
      // Load the SVG as an image
      const tempImage = new Image();
      tempImage.onload = function() {
        // Clear hidden canvas
        hiddenCtx.clearRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);
        
        // Draw SVG to hidden canvas
        hiddenCtx.drawImage(tempImage, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
        
        try {
          // Get the pixel data
          pixelData = hiddenCtx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height).data;
          infoPanel.textContent = "Ready - trace over the black lines";
        } catch (e) {
          console.error("Error getting SVG data:", e);
          infoPanel.textContent = "Error initializing - try refreshing";
        }
        
        // Clean up
        URL.revokeObjectURL(svgUrl);
      };
      
      tempImage.onerror = function() {
        console.error("Failed to load SVG as image");
        infoPanel.textContent = "Error loading sigil - try refreshing";
      };
      
      tempImage.src = svgUrl;
    }
    
    // Check if a point is on a black part of the sigil
    function isPointOnSigil(x, y) {
      if (!pixelData) return false;
      
      // Get pixel index
      const index = (Math.floor(y) * hiddenCanvas.width + Math.floor(x)) * 4;
      
      // Check boundaries
      if (index < 0 || index + 2 >= pixelData.length) return false;
      
      // Get RGB values
      const r = pixelData[index];
      const g = pixelData[index + 1];
      const b = pixelData[index + 2];
      
      // Check if dark enough (black or near-black)
      return (r + g + b) / 3 < 60;
    }
    
    // Touch event handler wrapper
    function handleTouch(eventHandler) {
      return function(e) {
        e.preventDefault();
        
        if (e.touches && e.touches.length > 0) {
          const touch = e.touches[0];
          const rect = drawCanvas.getBoundingClientRect();
          const x = touch.clientX - rect.left;
          const y = touch.clientY - rect.top;
          
          eventHandler({ offsetX: x, offsetY: y });
        }
      };
    }
    
    // Start drawing
    function startDrawing(e) {
      const x = e.offsetX;
      const y = e.offsetY;
      
      if (isPointOnSigil(x, y)) {
        isDrawing = true;
        lastPoint = { x, y };
        
        // Start a new path
        ctx.beginPath();
        ctx.moveTo(x, y);
      }
    }
    
    // Draw line following the cursor/touch
    function draw(e) {
      if (!isDrawing || !lastPoint) return;
      
      const x = e.offsetX;
      const y = e.offsetY;
      
      if (isPointOnSigil(x, y)) {
        // Set line style with rainbow effect
        ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.lineWidth = 10;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Draw line
        ctx.lineTo(x, y);
        ctx.stroke();
        
        // Update for next draw
        ctx.beginPath();
        ctx.moveTo(x, y);
        lastPoint = { x, y };
        
        // Cycle hue for rainbow effect
        hue = (hue + 2) % 360;
      } else {
        // Stop drawing if moved outside sigil
        stopDrawing();
      }
    }
    
    // Stop drawing
    function stopDrawing() {
      isDrawing = false;
      lastPoint = null;
      ctx.beginPath();
    }
    
    // Fade the trail over time
    function fadeTrail() {
      // Apply transparency to create fade
      ctx.fillStyle = 'rgba(231, 228, 220, 0.04)';
      ctx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
      
      // Continue animation
      requestAnimationFrame(fadeTrail);
    }
    
    // Initialize the app
    init();
  </script>
</body>
</html>
